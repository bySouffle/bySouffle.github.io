<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QPainter Pro</title>
      <link href="/2020/11/28/qt-6-painterpro/"/>
      <url>/2020/11/28/qt-6-painterpro/</url>
      
        <content type="html"><![CDATA[<h1 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h1><ul><li>三要素<ul><li>画在什么设备上？    pixmap  </li><li>用什么画在什么上？  painter =&gt; pixmap</li><li>渲染在什么部件上（render）？  QGraphicsView QGraphicsScene</li></ul></li></ul><h2 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a>QGraphicsView</h2><ul><li>显示</li></ul><hr><pre><code>_view = new QGraphicsView(this);</code></pre><hr><h2 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a>QGraphicsScene</h2><ul><li>现场  添加到显示里</li></ul><hr><pre><code>_view-&gt;setScene(_scene = new QGraphicsScene);</code></pre><hr><ul><li>在现场中添加 <strong>item</strong> </li><li>修改 <strong>item</strong> 的样式  </li></ul><hr><pre><code>_scene-&gt;addItem(lineitem = new QGraphicsLineItem(0,0,100,100));_scene-&gt;addItem(textitem = new QGraphicsTextItem("ohayo"));_scene-&gt;addItem(pixmapItem = new QGraphicsPixmapItem(QPixmap("../xxxx.png")));textitem-&gt;setPos(QPointF(200, 300));textitem-&gt;setFont(QFont("aaa",50,20,1));pixmapItem-&gt;setPos(100,100);</code></pre><hr><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><ul><li>先渲染图片<ul><li>三要素： 设备 画笔 渲染 ==&gt; 保存</li></ul></li></ul><hr><p>//        _view-&gt;render()   //重新操作一遍<br>//        _scene-&gt;render()</p><pre><code>    QPixmap pixmap(size()); //  先要有一个画的设备    QPainter painter(&amp;pixmap);  //  画的工具    painter.fillRect(QRect(0,0,size().width(),size().height()),Qt::white);  //  画板背景    _scene-&gt;render(&amp;painter);   //  渲染  用什么渲染（画笔） 在什么上渲染（pixmap）    pixmap.save("../abb.png");</code></pre><hr><h1 id="QGraphicsItemAnimation-动画"><a href="#QGraphicsItemAnimation-动画" class="headerlink" title="QGraphicsItemAnimation 动画"></a>QGraphicsItemAnimation 动画</h1><ul><li>加入 item ==&gt; 设置QTimeline  ==&gt; 循环次数 ==&gt; </li></ul><hr><pre><code>QGraphicsItemAnimation * animation = new QGraphicsItemAnimation;animation-&gt;setItem(pixmapItem);QTimeLine* timeline = new QTimeLine(3000);  // mstimeline-&gt;setLoopCount(2);animation-&gt;setTimeLine( timeline );animation-&gt;setTranslationAt(1,200,200);timeline-&gt;start();</code></pre><hr><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><hr><pre><code>timer = new QTimer();timer-&gt;setInterval(1000);   // 间隔1s// 超时做的事 connectconnect(timer,        &amp;QTimer::timeout,        this,        &amp;MyWidget::sl_timeout);timer-&gt;start();    //  只触发一次timer-&gt;singleShot(1000,this,&amp;MyWidget::sl_timeout);</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号槽</title>
      <link href="/2020/11/25/qt-5-xin-hao-cao/"/>
      <url>/2020/11/25/qt-5-xin-hao-cao/</url>
      
        <content type="html"><![CDATA[<h1 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h1><ul><li>信号的定义必须在 <strong>signals</strong> 保留字下，并且不需要实现</li><li>槽的定义在 <strong>slots</strong> 保留字下，需要实现 </li><li>信号和槽通过 QObject::connect 函数连接</li><li>当信号被触发 槽函数被调用</li></ul><hr><ul><li>信号和槽是QT的扩展 所以实现信号和槽的类必须是 <strong>QObject</strong> 的子类</li><li>实现信号和槽的类 必须以宏 <strong>Q_OBJECT</strong> 开始</li><li>连接信号和槽，要用到 <strong>SINGAL</strong> 和 <strong>SLOT</strong> 宏 转换函数为字符串</li><li>一个信号可以连接<strong>多个</strong>槽 槽函数调用顺序是不确定的</li><li>多个信号可以同时连接一个槽</li><li>信号可以连接信号，形成信号传导</li><li>信号和槽的<strong>参数</strong>应该一样多 而且<strong>类型</strong>必须相同</li><li>信号和槽都可以重载</li><li>信号和槽都可以有默认参数</li><li>槽函数可以像普通函数一样被调用</li><li>在槽函数中调用 <strong>sender</strong> 可以获得信号调用者</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一个类-QObject"><a href="#一个类-QObject" class="headerlink" title="一个类 QObject"></a>一个类 QObject</h3><h3 id="三个宏-Q-OBJECT-SIGNAL-SLOT"><a href="#三个宏-Q-OBJECT-SIGNAL-SLOT" class="headerlink" title="三个宏 Q_OBJECT SIGNAL SLOT"></a>三个宏 Q_OBJECT SIGNAL SLOT</h3><h3 id="三个保留字-signals-slots-emit"><a href="#三个保留字-signals-slots-emit" class="headerlink" title="三个保留字 signals slots emit"></a>三个保留字 signals slots emit</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT绘画</title>
      <link href="/2020/11/24/qt-4-painter/"/>
      <url>/2020/11/24/qt-4-painter/</url>
      
        <content type="html"><![CDATA[<h1 id="QT绘画-QPainter"><a href="#QT绘画-QPainter" class="headerlink" title="QT绘画 QPainter"></a>QT绘画 QPainter</h1><ul><li><p>重载 paintEvent</p><ol><li><p>准备画笔</p><pre><code> QPainter p(this);     p.setPen(QPen(Qt::red, 2, Qt::DashLine));     p.setBrush(Qt::yellow); //  背景颜色     p.setFont(QFont("aaa", 40, 700, true)); //italic</code></pre></li><li><p>绘制形状</p><pre><code> p.drawLine(QPoint(0,0), QPoint(100,100)); p.drawRect(QRect(40,60,100,50)); p.drawText(QPoint(300, 50), "Hellow"); p.drawPixmap(QPoint(40,40), QPixmap("../aaa.png"));</code></pre></li><li><p>图形变换</p><pre><code> {     QTransform transfrom;       //  可将复杂的功能组合     transfrom.rotate(30);     transfrom.scale(.5,.5);     //  缩放     p.setTransform(transfrom);  //  旋转 } p.translate(100,100);   //  变换原点坐标单独</code></pre></li><li><p>消除锯齿</p><pre><code> p.setRenderHint(QPainter::Antialiasing);    //  消除锯齿    </code></pre></li><li><p>*可以先画好图片放入pixmap中，再在窗口绘制</p><pre><code> QPixmap pixmap(size()); QPainter p(&amp;pixmap); QTransform transform; transform.translate(50,50); transform.rotate(30); p.setTransform(transform); p.drawxxx    ... ...  P.end(); p.begin(this); p.drawPixmap(0,0,pixmap);</code></pre></li></ol></li></ul><h2 id="示例1（画板实现）"><a href="#示例1（画板实现）" class="headerlink" title="示例1（画板实现）"></a>示例1（画板实现）</h2><hr><pre><code>// MyWidget.h #include&lt;QVector&gt;#include &lt;QDebug&gt;    class MyWidget : public QWidget{    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);    MyButton * button;    void paintEvent(QPaintEvent *);    void mousePressEvent(QMouseEvent *);    void mouseReleaseEvent(QMouseEvent *);    void mouseMoveEvent(QMouseEvent *);    QVector&lt;QPoint&gt; _pos;    QVector&lt; QVector&lt;QPoint&gt; &gt; _lines;signals:};</code></pre><hr><hr><pre><code>//MyWidget.cppvoid MyWidget::paintEvent(QPaintEvent *event){    QPainter p(this);    for(int i = 0; i &lt; _lines.size();++i)    {        const QVector&lt;QPoint&gt; &amp; line = _lines.at(i);        {            for(int j = 0; j &lt; line.size()-1; ++j)            {                p.drawLine(line.at(j),line.at(j+1));            }        }    }}void MyWidget::mouseMoveEvent(QMouseEvent *event){    if(_lines.size() == 0)    {        QVector&lt;QPoint&gt; line;        _lines.append(line);    }    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());    update();}void MyWidget::mouseReleaseEvent(QMouseEvent *event){    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());}void MyWidget::mousePressEvent(QMouseEvent *event){    QVector&lt;QPoint&gt; line;   //  一条线    _lines.append(line);     // 一条线放入很多条线 的向量里    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());}</code></pre><hr><h2 id="示例2-按钮变色"><a href="#示例2-按钮变色" class="headerlink" title="示例2 按钮变色"></a>示例2 按钮变色</h2><hr><pre><code>//  MyButton.h#ifndef MYBUTTON_H#define MYBUTTON_H#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;class MyButton : public QWidget{    Q_OBJECTpublic:    explicit MyButton(QWidget *parent = nullptr);    MyButton(const QString &amp;text, QWidget* parent = 0);    QRect _rect;    //  按钮大小    QString _text;  //  按钮显示文字    bool _pressed;  //  按压判断    void paintEvent(QPaintEvent *event);    void mousePressEvent(QMouseEvent *event);    void mouseReleaseEvent(QMouseEvent *event);signals:    void clicked();};#endif // MYBUTTON_H</code></pre><hr><hr><pre><code>//  MuButton.cpp#include "MyButton.h"#include &lt;QPainter&gt;MyButton::MyButton(QWidget *parent) :    QWidget(parent), _rect(0,0,100,30){    _pressed = false;   //  初始时 按压设置为否    this-&gt;setGeometry(_rect);}MyButton::MyButton(const QString &amp;text, QWidget *parent):                        QWidget(parent), _text(text), _rect(0,0,100,30){    _pressed = false;    this-&gt;setGeometry(_rect);}void MyButton::paintEvent(QPaintEvent *event){    QPainter p(this);    if( _pressed == true )    {        p.setBrush(Qt::yellow); //  设置背景为黄色    }    else        p.setBrush(Qt::darkGray);   //  设置背景为灰色    p.drawRect(_rect);  //  画按钮框    p.drawText(_rect, _text, QTextOption(Qt::AlignCenter)); //  画文字}void MyButton::mousePressEvent(QMouseEvent *event){    //  按下时 按钮状态为 true 更新颜色    _pressed = true;    update();}void MyButton::mouseReleaseEvent(QMouseEvent *event){    //  释放时 按钮状态为 false 更新颜色    _pressed = false;    update();    //  在设定框框的容器范围内才发送信号    if(_rect.contains(event-&gt;pos()))    {    emit clicked();    }//    emit clicked();}</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT控件</title>
      <link href="/2020/11/24/qt-3-shi-jian/"/>
      <url>/2020/11/24/qt-3-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><ul><li><p>QApplication 先得到 ==&gt; 具体应该处理的窗口：event() ==&gt; event() 根据消息的类型来调用具体的虚函数 </p></li><li><p>重载具体的虚函数来实现对消息的相应</p></li><li><p>重载 event 函数来处理或截取消息</p></li></ul><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><ol><li>在处理的类里重载事件</li></ol><hr><pre><code>class MyWidget : public QWidget{    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);// *************** event **********************//    bool event(QEvent *);    void mousePressEvent(QMouseEvent *event);    void mouseReleaseEvent(QMouseEvent *event);    void mouseMoveEvent(QMouseEvent *event);    void keyPressEvent(QKeyEvent *event);    void closeEvent(QCloseEvent *event);    void hideEvent(QHideEvent *event);    void paintEvent(QPaintEvent *event);    void resizeEvent(QResizeEvent *event);// *********************************************    QPushButton *button;    QPushButton *button1;    QVBoxLayout *vlay;    QTextEdit * edit;    void sl_buttonChecked();signals:};</code></pre><hr><ol start="2"><li><p>截断消息</p><p> 重载event函数来处理或者截取消息</p></li></ol><hr><pre><code>bool MyWidget::event(QEvent *ev){    if(ev-&gt;type() == QEvent::MouseButtonPress)    {        qDebug()&lt;&lt;"111";        return QWidget::event(ev);    }}</code></pre><hr><ol start="3"><li><p>重写 事件</p><p> 重载具体的虚函数来实现对消息的相应</p></li></ol><hr><pre><code>void MyWidget::keyPressEvent(QKeyEvent *event){    event-&gt;modifiers() ;    int key = event-&gt;key();    qDebug()&lt;&lt;key;    char keys = key;    qDebug()&lt;&lt;keys;}void MyWidget::mousePressEvent(QMouseEvent *event){    QPoint pt = event-&gt;pos();    qDebug()&lt;&lt;pt;    if(event-&gt;button() == Qt::LeftButton)    {        qDebug()&lt;&lt;"left";    }    if(event-&gt;modifiers()== Qt::ShiftModifier)  //  修饰符shift    {        qDebug()&lt;&lt;"shift press";    }    if(event-&gt;modifiers() == Qt::ControlModifier)    {        qDebug()&lt;&lt;"control";        return ;    }}   </code></pre><hr><ol start="4"><li><p>注意事项</p><ul><li><p>鼠标事件在窗口上处理不包含按钮等部件  鼠标按下才会有反应</p><p>  解决方法: </p><pre><code>  this-&gt;setMouseTracking(true);</code></pre></li></ul></li></ol><pre><code>* 键盘事件在主窗口上处理, 不会处理按键等    解决方法: 设置 焦点 or 将按键设置默认        button-&gt;setFocus(); //  设置焦点        button-&gt;setDefault(true);   //  设为默认</code></pre><h2 id="事件过滤"><a href="#事件过滤" class="headerlink" title="事件过滤"></a>事件过滤</h2><ol><li><p>给 <strong>Widget</strong> 安装一个消息过滤器， 经过 <strong>Widget</strong> 的消息都要先经过 <strong>eventfilter</strong> </p><pre><code> button-&gt;installEventFilter(this);</code></pre></li><li><p>重写 eventFilter 函数</p><pre><code> bool eventFilter(QObject *, QEvent *); bool MyWidget::eventFilter(QObject *o, QEvent *e) {     if(((QPushButton *)_button == o ) &amp;&amp;             (e-&gt;type() == QEvent::MouseButtonRelease ||             e-&gt;type() == QEvent::MouseButtonDblClick||             e-&gt;type() == QEvent::MouseButtonPress))     {         return true;     }     return QWidget::eventFilter(o,e); }</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT控件</title>
      <link href="/2020/11/23/qt-2-kong-jian/"/>
      <url>/2020/11/23/qt-2-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><h2 id="QLabel-addWidget"><a href="#QLabel-addWidget" class="headerlink" title="QLabel   (addWidget)"></a>QLabel   (addWidget)</h2><ul><li>是一个部件，添加到布局里</li><li>标签的文字支持 html 语言</li></ul><h2 id="QComboBox-（addWidget）"><a href="#QComboBox-（addWidget）" class="headerlink" title="QComboBox    （addWidget）"></a>QComboBox    （addWidget）</h2><ul><li>下拉框</li></ul><hr><pre><code>QComboBox *combo;lay-&gt;addWidget(combo = new QComboBox());</code></pre><hr><ul><li>添加选项</li></ul><hr><pre><code>combo-&gt;addItem("select 1");combo-&gt;addItem("select 2");</code></pre><hr><ul><li>可编辑选项</li></ul><hr><pre><code>combo-&gt;setEditable(true);  // 可编辑的下拉框</code></pre><hr><ul><li>根据输入选择下拉选项</li></ul><hr><pre><code>combo-&gt;setCompleter(new QCompleter(combo-&gt;model()));</code></pre><hr><h2 id="QTextEdit-addWidget"><a href="#QTextEdit-addWidget" class="headerlink" title="QTextEdit     (addWidget)"></a>QTextEdit     (addWidget)</h2><ul><li>文本编辑框 可以给定 Html 语言格式，如&lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;imag src=../xxx.png&gt;&lt;\imag&gt;…</li></ul><hr><pre><code>lay-&gt;addWidget(edit = new QTextEdit);    edit-&gt;setText("&lt;table border=1&gt;&lt;tr&gt;&lt;th&gt;head1&lt;/th&gt;&lt;/tr&gt;"                "&lt;tr&gt;&lt;td&gt;value1&lt;/td&gt;value2&lt;td&gt;zzz&lt;/td&gt;&lt;/1tr&gt;"                "&lt;tr&gt;&lt;td&gt;value3&lt;/td&gt;value4&lt;td&gt;zzz&lt;/td&gt;&lt;/tr&gt;"                "&lt;/table&gt;""&lt;br&gt;""&lt;imag src=../aaa.png&gt;&lt;/imag&gt;"                );        //Html 表格插数据</code></pre><hr><ul><li>检测文本路径转为图片显示</li></ul><hr><pre><code>edit-&gt;toPlainText();</code></pre><hr><ul><li>侧边移动滑条</li></ul><hr><pre><code>edit-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);edit-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);</code></pre><hr><h2 id="QGroupBox-addWidget"><a href="#QGroupBox-addWidget" class="headerlink" title="QGroupBox    (addWidget)"></a>QGroupBox    (addWidget)</h2><ul><li>左上角名字将部件圈起来的框框</li></ul><hr><pre><code>lay-&gt;addWidget(groupbox = new QGroupBox("Some Items"));</code></pre><hr><p>*再在框框内添加layout, 再在layout内添加部件</p><hr><pre><code>groupbox-&gt;setLayout(hboxlay = new QHBoxLayout);hboxlay-&gt;addWidget(new QLabel("aaaa"));hboxlay-&gt;addWidget(new QLabel("aaaa"));</code></pre><hr><h2 id="QSlider-（滑杆）"><a href="#QSlider-（滑杆）" class="headerlink" title="QSlider  （滑杆）"></a>QSlider  （滑杆）</h2><ul><li>布局 默认竖直放置, 下面为水平放置</li></ul><hr><pre><code>lay-&gt;addWidget(slider = new QSlider(Qt::Horizontal));</code></pre><hr><ul><li>设置上下限</li></ul><hr><pre><code>slider-&gt;setMaximum(100);slider-&gt;setMinimum(0);</code></pre><hr><h2 id="QSpinBox-（数字调节）"><a href="#QSpinBox-（数字调节）" class="headerlink" title="QSpinBox     （数字调节）"></a>QSpinBox     （数字调节）</h2><hr><pre><code>lay-&gt;addWidget(spinBox = new QSpinBox); </code></pre><hr><h3 id="将-QSlider-与-QSpinBox-结合"><a href="#将-QSlider-与-QSpinBox-结合" class="headerlink" title="将 QSlider 与 QSpinBox 结合"></a>将 QSlider 与 QSpinBox 结合</h3><hr><pre><code>connect(slider,        &amp;QSlider::valueChanged,        spinBox,        &amp;QSpinBox::setValue);connect(spinBox,        SIGNAL(valueChanged(int)),        slider,        SLOT(setValue(int)));</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux C线程</title>
      <link href="/2020/11/18/c-thread/"/>
      <url>/2020/11/18/c-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><hr><pre><code>#include &lt;pthread.h&gt;</code></pre><hr><h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><hr><pre><code>extern int pthreacreated_create (pthread_t *__restrict __newthread,           const pthread_attr_t *__restrict __attr,           void *(*__start_routine) (void *),           void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>线程ID的指针</li></ul><hr><pre><code>pthread_t *__restrict __newthread,</code></pre><hr><pre><code>//  创建方式pthread_t work_thread;pthread_t wait_thread;</code></pre><ul><li>线程属性设置</li></ul><hr><pre><code>const pthread_attr_t *__restrict __attr,</code></pre><hr><pre><code>//  创建属性pthread_attr_t attr;       //线程属性设置pthread_attr_init(&amp;attr);//将属性设置为joinable, 使主线程等待该线程执行完后，再结束主线程pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_JOINABLE);   </code></pre><ul><li>执行的线程函数  &amp;  参数</li></ul><hr><pre><code>//  函数参数void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><pre><code>//  创建传递线程参数的结构体struct thread_para{    int sockfd;    char *info;};thread_para thread_p;</code></pre><hr><pre><code>//  函数指针void *(*__start_routine) (void *),</code></pre><hr><hr><pre><code>//  创建线程函数void *work_recv_thread(void *param){    //  将传入的结构体强转类型    thread_para *t_para = (thread_para* )param;    ... ...}</code></pre><hr><ul><li>创建线程</li></ul><hr><pre><code>extern int pthread_create (pthread_t *__restrict __newthread,           const pthread_attr_t *__restrict __attr,           void *(*__start_routine) (void *),           void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><hr><pre><code>创建一个线程pthread_create(    &amp;work_thread,    NULL,    work_recv_thread,    (void *)&amp;thread_p);</code></pre><hr><ul><li>阻塞式(等待子线程运行完再结束主线程)</li></ul><hr><pre><code>extern int pthread_join (pthread_t __th, void **__thread_return);pthread_t __th  //  线程IDvoid **__thread_return  //  返回的线程状态信息，类型为void*//ex:void *status;pthread_join(    wait_thread,    &amp;status);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT基础</title>
      <link href="/2020/11/15/qt-1-ji-chu/"/>
      <url>/2020/11/15/qt-1-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="QT基础"><a href="#QT基础" class="headerlink" title="QT基础"></a>QT基础</h1><h2 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h2><ul><li>空的父系窗口，可以包含QPushbutton、QLineEdit、Layout等部件</li></ul><hr><pre><code>QWidget w;w.setWindowTitle("zzz");//  显示窗口w.show();</code></pre><hr><h2 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h2><ul><li>按钮也是一个窗口 继承QWidget</li></ul><hr><pre><code>QPushButton button;button.setText("quit");</code></pre><hr><ol><li>窗口之间存在父子关系,没有父子对象的窗口为主窗口</li></ol><hr><pre><code>button.setParent(&amp;w);</code></pre><hr><ol start="2"><li>setGeometry(x, y, l, w) 设置几何位置</li></ol><hr><pre><code>button.setGeometry(20,20,100,30);</code></pre><hr><h2 id="QLineEdit"><a href="#QLineEdit" class="headerlink" title="QLineEdit"></a>QLineEdit</h2><ul><li>文本输入框</li></ul><hr><pre><code>QLineEdit edit;edit.setParent(&amp;w);</code></pre><hr><ol><li>显示方式(输入密码那种样子)</li></ol><hr><pre><code>edit.setEchoMode(QLineEdit::Password);edit.text();</code></pre><hr><ol start="2"><li><p>输入匹配</p><p> (1) 创建一个预期的QStringList</p><p> (2) 创建一个QCompleter completer(QStringList()&lt;&lt;””);</p><p> (3) 匹配模式<br> completer.setFilterMode(Qt::MatchContains)</p><p> (4) 设置模式到QLineEdit</p></li></ol><hr><pre><code>QCompleter completer(QStringList()&lt;&lt;"123" &lt;&lt;"abc");completer.setFilterMode(Qt::MatchContains);edit.setCompleter(&amp;completer);</code></pre><hr><ol start="3"><li>默认显示</li></ol><hr><pre><code>edit.setPlaceholderText("gogogo");edit.setParent(&amp;w);</code></pre><hr><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><ul><li><p>用<strong>QVBoxLayout</strong>、<strong>QHBoxLayout</strong>、<strong>QGridLayout</strong> 创建一个Layout</p></li><li><p>将按钮啥的放到 部件 里 layout.addWidget()</p></li><li><p>将Layout放到 QWidget 里 addWidget(&amp; layout)</p><ol><li>添加空位addSpacing</li><li>addStretch 弹簧一样将layout中的 部件 压到一块 参数为比例</li></ol></li></ul><hr><pre><code>QHBoxLayout h_layout;//  addWidget 第二个参数是部件的长度比例h_layout.addWidget(&amp;button,1);h_layout.addWidget(&amp;edit,2);h_layout.addStretch(2);w.setLayout(&amp;h_layout);</code></pre><hr><ul><li>QGridLayout 矩阵式多个部件</li></ul><hr><pre><code>QGridLayout g_layout;//  QGridLayout 矩阵式多个部件g_layout.addWidget(&amp;button,0,0);g_layout.addWidget(&amp;edit,0,1);g_layout.addWidget(new QPushButton("1, 0"),1,0);g_layout.addWidget(new QPushButton("1, 1"),1,1);g_layout.setColumnStretch(2,1);g_layout.setRowStretch(2,1);w.setLayout(&amp;g_layout);</code></pre><hr><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><hr><pre><code>//  登录界面/*  1. 居中 *  2. 用户名 label   edit *  3. 密码   label   edit *  4. 确认   button *      */QWidget *w = new QWidget;QLabel *m_l_username = new QLabel;QLabel *m_l_passwd = new QLabel;QLineEdit *m_e_username = new QLineEdit;QLineEdit *m_e_passwd = new QLineEdit;QPushButton *m_login_bt = new QPushButton;QGridLayout *m_login_glayout = new QGridLayout;QHBoxLayout *m_login_bt_l = new QHBoxLayout;m_l_username-&gt;setText("用户名:");m_login_glayout-&gt;addWidget(m_l_username,1,1);//  m_login_glayout-&gt;setSpacing(10);m_e_username-&gt;setMaxLength(8);m_login_glayout-&gt;addWidget(m_e_username,1,2);m_l_passwd-&gt;setText("密码:");m_login_glayout-&gt;addWidget(m_l_passwd,2,1);m_login_glayout-&gt;setSpacing(10);m_e_passwd-&gt;setEchoMode(QLineEdit::Password);m_login_glayout-&gt;addWidget(m_e_passwd,2,2);m_login_glayout-&gt;setRowStretch(0,1);m_login_glayout-&gt;setColumnStretch(0,1);m_login_glayout-&gt;setRowStretch(4,1);m_login_glayout-&gt;setColumnStretch(4,1);m_login_bt-&gt;setText("登录");m_login_bt_l-&gt;addStretch(1);m_login_bt_l-&gt;addWidget(m_login_bt);m_login_glayout-&gt;addLayout(m_login_bt_l,3,2);//    m_login_glayout-&gt;addWidget(m_login_bt,3,2);w-&gt;setLayout(m_login_glayout);//    w-&gt;setLayout()w-&gt;show();</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT窗口部件</title>
      <link href="/2020/11/07/qt-1/"/>
      <url>/2020/11/07/qt-1/</url>
      
        <content type="html"><![CDATA[<h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><h3 id="一-各种部件"><a href="#一-各种部件" class="headerlink" title="一.  各种部件"></a>一.  各种部件</h3><ul><li><strong>QWidget</strong> 现理解的作用就是包起其他的部件，如QVboxLayout</li></ul><hr><pre><code>// 创建一个QWidegetQWidget w;  //  创建实例对象QWidget *w1 = new QWidget;  //  创建指针(推荐)</code></pre><hr><ul><li><strong>QVBoxLayout(QHboxLayout)</strong> 存放各种按钮框框啥的吧</li></ul><hr><pre><code>//  创建一个QVBoxLayoutQVBoxLayout box;  //  创建实例对象QVBoxLayout *box = new QVBoxLayout;  //  创建指针</code></pre><hr><ul><li><strong>QPushButton</strong> 按钮</li></ul><hr><pre><code>QPushButton quit("quit");//  1.将按钮放入 BoxLayoutbox-&gt;addWidget(&amp;hello);QObject::connect(        &amp;quit,                  // 按下buttom发出信号的对象        &amp;QPushButton::clicked,  // 点击信号          &amp;a,                     // 接受信号的对象        &amp;QApplication::quit     // 槽 实现功能 退出        );//  2.BoxLayout 放入 QWidgetw-&gt;setLayout(&amp;box);//  3.显示w-&gt;show();</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与指针</title>
      <link href="/2020/10/24/array-point/"/>
      <url>/2020/10/24/array-point/</url>
      
        <content type="html"><![CDATA[<h2 id="数据与指针"><a href="#数据与指针" class="headerlink" title="数据与指针"></a>数据与指针</h2><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.  概念"></a>一.  概念</h3><ul><li>数组：储存多个相同类型元素</li><li>指针：自身储存指向对象的地址</li></ul><h3 id="二-赋值"><a href="#二-赋值" class="headerlink" title="二. 赋值"></a>二. 赋值</h3><blockquote><p>数组</p><ul><li>1</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/10/24/hello-world/"/>
      <url>/2020/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/08/02/test/"/>
      <url>/2020/08/02/test/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>print("hello world")</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
