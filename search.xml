<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 多线程创建</title>
      <link href="/2021/03/16/c-thread/"/>
      <url>/2021/03/16/c-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多线程操作"><a href="#C-多线程操作" class="headerlink" title="C++ 多线程操作"></a>C++ 多线程操作</h1><h2 id="一-函数对象创建线程"><a href="#一-函数对象创建线程" class="headerlink" title="一. 函数对象创建线程"></a>一. 函数对象创建线程</h2><pre><code>#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;void func()&#123;    cout &lt;&lt; &quot;strat&quot; &lt;&lt;endl;    cout &lt;&lt; &quot;end&quot; &lt;&lt;endl;&#125;int main()&#123;    thread m_thread(func);    m_thread.join();    cout &lt;&lt; &quot;zzz&quot; &lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="二-用类对象创建线程"><a href="#二-用类对象创建线程" class="headerlink" title="二. 用类对象创建线程"></a>二. 用类对象创建线程</h2><p>1.</p><pre><code>#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;// 类要变成可调用对象需要重载操作符（）class T&#123;    public:        void operator()()   //不能带参数，代码从这开始执行        &#123;        cout&lt;&lt;&quot;start&quot;&lt;&lt;endl;        //...        cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;        &#125;&#125;int main()&#123;    T t;    thread m_thread(t);    m_thread.join();    cout &lt;&lt; &quot;zzz&quot; &lt;&lt;endl;    return 0;&#125;</code></pre><p>2.</p><pre><code>#include&lt;iostream&gt;#include&lt;pthread.h&gt;// 类要变成调用对象需要重载操作符class T&#123;    public:        int m;        T(int i):m(i)        &#123;        &#125;        void operator()()   //不能带参数 代码从这开始        &#123;            cout &lt;&lt; &quot;start&quot; &lt;&lt; endl;            //...            cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;        &#125;&#125;;int main()&#123;    int m = 6;    T t(m);    thread m_thread(t);    m_thread.join();    cout &lt;&lt; &quot;zzz&quot; &lt;&lt; endl;&#125;</code></pre><h2 id="三-将类中的某个函数作为线程的入口地址"><a href="#三-将类中的某个函数作为线程的入口地址" class="headerlink" title="三. 将类中的某个函数作为线程的入口地址"></a>三. 将类中的某个函数作为线程的入口地址</h2><pre><code>class T&#123;    public:        void GetMsg()        &#123;        &#125;        void SaveMsg()        &#123;        &#125;&#125;T t;// 第一个是取址 第二个是引用thread obj1(&amp;T::GetMsg, &amp;t);thread obj2(&amp;T::SaveMsg, &amp;t);obj1.join();obj2.join();</code></pre><h2 id="四-lambda-表达式创建线程"><a href="#四-lambda-表达式创建线程" class="headerlink" title="四. lambda 表达式创建线程"></a>四. lambda 表达式创建线程</h2><pre><code>#include&lt;iostream&gt;#include&lt;pthread.h&gt;using namespace std;int main()&#123;    auto m_lambda = []    &#123;        cout &lt;&lt; &quot;start&quot; &lt;&lt; endl;     &#125;    thread m_thread(m_lambda);    m_thread.join();    cout &lt;&lt; &quot;zz&quot; &lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Serial 配置</title>
      <link href="/2021/02/25/linux-serial/"/>
      <url>/2021/02/25/linux-serial/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-串口配置"><a href="#Linux-串口配置" class="headerlink" title="Linux 串口配置"></a>Linux 串口配置</h1><h2 id="1-波特率"><a href="#1-波特率" class="headerlink" title="1. 波特率"></a>1. 波特率</h2>]]></content>
      
      
      <categories>
          
          <category> Linux/Serial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux/Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/02/09/filereadme/"/>
      <url>/2021/02/09/filereadme/</url>
      
        <content type="html"><![CDATA[<pre><code>ethercat-1.5.2-patch.tar.gz     打过补丁的ethercat包linux-4.19.152.tar.gz           普通的linux源代码linux-4.19.152-patch.tar.gz     打过xenomai补丁的linux源代码    xenomai-image-headers.tar.gz    xenomai安装镜像以及头文件   libxenomai.tar.gz               xenomai所需库   ipipe-core-4.19.152-cip37-x86-15.patch  cobalt-core-4.19.152-v3.1-rc4.patch  </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT Linux pack</title>
      <link href="/2020/12/25/qt-ldd-pack/"/>
      <url>/2020/12/25/qt-ldd-pack/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-ldd-方法-打包跨-Linux-无QT环境应用"><a href="#QT-ldd-方法-打包跨-Linux-无QT环境应用" class="headerlink" title="QT ldd 方法 打包跨 Linux 无QT环境应用"></a>QT ldd 方法 打包跨 Linux 无QT环境应用</h1><h3 id="1-新建一个文件夹-准备-ldd-输出脚本和应用运行脚本"><a href="#1-新建一个文件夹-准备-ldd-输出脚本和应用运行脚本" class="headerlink" title="1. 新建一个文件夹 准备 ldd 输出脚本和应用运行脚本"></a>1. 新建一个文件夹 准备 ldd 输出脚本和应用运行脚本</h3><hr><pre><code># ldd.sh  ldd 输出脚本#! /bin/bashLibDir=$PWD"/lib"Target=$1lib_array=($(ldd $Target | grep -o "/.*" | grep -o "/.*/[^[:space:]]*"))$(mkdir $LibDir)for Variable in ${lib_array[@]}do    cp "$Variable" $LibDirdone</code></pre><hr><hr><pre><code># xxx.sh 应用运行脚本   !!!!!!!! 脚本名字与 QT release 生成的应用名字一致#!/bin/shappname=`basename $0 | sed s,\.sh$,,`dirname=`dirname $0`tmp="${dirname#?}"if [ "${dirname%$tmp}" != "/" ]; thendirname=$PWD/$dirnamefiLD_LIBRARY_PATH=$dirnameexport LD_LIBRARY_PATH$dirname/$appname "$@"</code></pre><hr><h3 id="2-给两个脚本添加可执行权限"><a href="#2-给两个脚本添加可执行权限" class="headerlink" title="2. 给两个脚本添加可执行权限"></a>2. 给两个脚本添加可执行权限</h3><pre><code>sudo chmod 777 ldd.shsudo chmod 777 xxx.sh   //  !!!!!!!! 脚本名字与 QT release 生成的应用名字一致</code></pre><h3 id="3-新建一个存放打包应用的文件夹"><a href="#3-新建一个存放打包应用的文件夹" class="headerlink" title="3. 新建一个存放打包应用的文件夹"></a>3. 新建一个存放打包应用的文件夹</h3><hr><h3 id="4-将-ldd-sh-复制到-QT-编译的-release-目录"><a href="#4-将-ldd-sh-复制到-QT-编译的-release-目录" class="headerlink" title="4. 将 ldd.sh 复制到 QT 编译的 release 目录"></a>4. 将 ldd.sh 复制到 QT 编译的 release 目录</h3><pre><code># 执行./ldd.sh xxx之后将 lib 文件复制到第三步创建的文件夹中</code></pre><h3 id="5-将-ldd-sh-复制到-QT-安装目录的-platforms-文件夹中"><a href="#5-将-ldd-sh-复制到-QT-安装目录的-platforms-文件夹中" class="headerlink" title="5. 将 ldd.sh 复制到 QT 安装目录的 platforms 文件夹中"></a>5. 将 ldd.sh 复制到 QT 安装目录的 platforms 文件夹中</h3><pre><code># 执行./ldd.sh libqxcb.so之后将 lib 文件复制到第三步创建的文件夹中</code></pre><h3 id="6-将-platforms-整个文件夹复制到第三步创建的文件夹中"><a href="#6-将-platforms-整个文件夹复制到第三步创建的文件夹中" class="headerlink" title="6. 将 platforms 整个文件夹复制到第三步创建的文件夹中"></a>6. 将 platforms 整个文件夹复制到第三步创建的文件夹中</h3><hr><h3 id="7-将-xxx-sh-复制到第三步创建的文件夹中，运行脚本"><a href="#7-将-xxx-sh-复制到第三步创建的文件夹中，运行脚本" class="headerlink" title="7. 将 xxx.sh 复制到第三步创建的文件夹中，运行脚本"></a>7. 将 xxx.sh 复制到第三步创建的文件夹中，运行脚本</h3><hr><h3 id="8-如果跨-linux-段错误，删除公有库，如果不知道哪些是，可将除QT外的库拷贝到另一个文件夹中，运行程序，差什么加什么。"><a href="#8-如果跨-linux-段错误，删除公有库，如果不知道哪些是，可将除QT外的库拷贝到另一个文件夹中，运行程序，差什么加什么。" class="headerlink" title="8. 如果跨 linux 段错误，删除公有库，如果不知道哪些是，可将除QT外的库拷贝到另一个文件夹中，运行程序，差什么加什么。"></a>8. 如果跨 linux 段错误，删除公有库，如果不知道哪些是，可将除QT外的库拷贝到另一个文件夹中，运行程序，差什么加什么。</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT表查找</title>
      <link href="/2020/12/07/qt-biao-cha-xun/"/>
      <url>/2020/12/07/qt-biao-cha-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="QT表查找"><a href="#QT表查找" class="headerlink" title="QT表查找"></a>QT表查找</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>需要将某头文件中的 menu 作为QComboBox 的选项选择 且返回 menu </li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><ol><li>首先声明一个结构体，包含选项名字和实际返回的 menu 类型 </li></ol></li></ul><pre><code>        struct baudrate_item        {            QString m_name ;            QSerialPort::BaudRate m_baudrate;        } ;</code></pre><ol start="2"><li><p>接着声明一个上述结构体的 List</p><pre><code>   QList &lt; baudrate_item &gt; m_baudrate_list ;</code></pre></li><li><p>定义一个 func 按顺序填充这个 List</p><pre><code>   void environment::fun_cons_baudrate_list()   {       m_baudrate_list.clear() ;</code></pre></li></ol><pre><code>            {                baudrate_item  item ;                item.m_name = "115200" ;                item.m_baudrate =  QSerialPort::Baud115200 ;                m_baudrate_list.append( item ) ;            }            {                baudrate_item  item ;                item.m_name = "57600" ;                item.m_baudrate =  QSerialPort::Baud57600 ;                m_baudrate_list.append( item ) ;            }                   ... ...        }4. 定义一个 func 返回选项 Name 的 List        QStringList environment::fun_get_baudrate_str()        {            QStringList i_str_list  ;            i_str_list.clear() ;            for(int i = 0 ; i &lt; m_baudrate_list.size() ; i++ )            {                i_str_list.append( m_baudrate_list.at(i).m_name );            }            return  i_str_list ;        }5. 定义一个 func，通过索引返回 emnu 类型的参数        QSerialPort::BaudRate environment::fun_get_idx_of_enum(int idx)        {            QSerialPort::BaudRate i_baudrate = QSerialPort::Baud115200 ;            if( m_baudrate_list.size() &gt; idx)            {                i_baudrate = m_baudrate_list.at(idx).m_baudrate ;            }            return  i_baudrate ;        }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT/设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT/设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多次引用重复定义问题</title>
      <link href="/2020/12/04/c-chong-fu-ding-yi/"/>
      <url>/2020/12/04/c-chong-fu-ding-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多次引用重复定义问题"><a href="#C-多次引用重复定义问题" class="headerlink" title="C++ 多次引用重复定义问题"></a>C++ 多次引用重复定义问题</h1><ul><li>写Qt的时候遇到的环境变量引用的问题，当需要初始化一个变量并在另一个 Class 内使用时，在 Class 类中引用这个头文件，会出现重复定义的问题。</li></ul><h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法:"></a>解决的方法:</h2><ul><li><p>创建两个头文件 <strong>gl_extern.h</strong> 和 <strong>gl_para.h</strong></p><p>  在 <strong>gl_extern.h</strong> 中声明的函数和变量可以在本模块活其他模块中使用</p><pre><code>  // gl_extern.h  #ifndef GL_EXTERN_H  #define GL_EXTERN_H  #include &lt;QString&gt;  #include &lt;QStringList&gt;  extern QStringList  m_port_list;  #endif // GL_EXTERN_H</code></pre><p>  在 <strong>gl_para.h</strong> 中定义这个全局变量</p><pre><code>  // gl_para.h  #ifndef GL_PARA_H  #define GL_PARA_H  #include &lt;QString&gt;  #include &lt;QStringList&gt;  QStringList  m_port_list;  #endif // GL_PARA_H</code></pre></li></ul><pre><code>之后在需要使用的地方包含这两个头文件</code></pre><hr><ul><li><p>单例设计模式</p><pre><code>  创建一个环境变量的类  #ifndef ENVIRONMENT_H  #define ENVIRONMENT_H  #include &lt;QStringList&gt;</code></pre></li></ul><pre><code>    class environment    {        environment();    public:        static environment *  fun_get_entity()        {            static  environment m_p_env    ;            return  &amp;m_p_env ;        }    public:        QStringList m_list ;    };    #endif // ENVIRONMENT_H在需要使用的地方    environment * m_p_env = environment::fun_get_entity() ;在需要用到的类里    // 常量区创建指针    environment * m_p_env ;    // 构造函数中调用    m_p_env = environment::fun_get_entity() ;    // 使用的地方    m_p_env-&gt;fun_get_idx_of_enum( index );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/2020/12/02/qt-10-socket/"/>
      <url>/2020/12/02/qt-10-socket/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-Socket"><a href="#QT-Socket" class="headerlink" title="QT Socket"></a>QT Socket</h1><h2 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h2><pre><code>QT += network </code></pre><ul><li><p>创建一个 TcpServer</p><pre><code>  QTcpServer *server = new QTcpServer;</code></pre></li><li><p>监听</p><pre><code>  server-&gt;listen(QHostAddress::Any, 9988);</code></pre></li><li><p>connect 新连接</p><pre><code>  connect(server,          &amp;QTcpServer::newConnection,          this,          &amp;TcpServer::sl_serconnect          );</code></pre></li><li><p>slot 处理新来的连接 然后用一个 socket 接管新来的连接 之后 connect 处理读写</p><pre><code>  void TcpServer::sl_serconnect()  {      //  有多个连接一次不取出来只调用一次nextPendingConnection      while (_server-&gt;hasPendingConnections())      {          socket = server-&gt;nextPendingConnection();          connect(socket,                  &amp;QTcpSocket::readyRead,                  this,                  &amp;TcpServer::sl_readyread                  );      }  }  void TcpServer::sl_readyread()  {      QByteArray buf = _socket-&gt;readAll();      _textbrowser-&gt;append(buf);  }</code></pre></li></ul><h2 id="TcpSocket"><a href="#TcpSocket" class="headerlink" title="TcpSocket"></a>TcpSocket</h2><ul><li><p>创建一个 Tcpclient</p><pre><code>  QTcpSocket *client = new QTcpSocket(this);</code></pre></li><li><p>连接server</p><pre><code>  client-&gt;connectToHost("127.0.0.1", 9988);</code></pre></li><li><p>写数据</p><pre><code>  client-&gt;write(strText.toUtf8());</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MainWindow</title>
      <link href="/2020/12/01/qt-8-mainwindow/"/>
      <url>/2020/12/01/qt-8-mainwindow/</url>
      
        <content type="html"><![CDATA[<h1 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h1><p>含有 QMenuBar, QToolBar 和 QStatusBar的窗口</p><h2 id="QMenuBar"><a href="#QMenuBar" class="headerlink" title="QMenuBar"></a>QMenuBar</h2><pre><code>QMenuBar *pMenuBar = menuBar();</code></pre><h3 id="QMenu"><a href="#QMenu" class="headerlink" title="QMenu"></a>QMenu</h3><pre><code>QMenu *menu = pMenuBar-&gt;addMenu(&quot;&amp;File&quot;);</code></pre><ul><li><p>当需要在其他地方使用 menu 时, 可以创建一个 _menu 指针等于 menu</p><pre><code>  _menu = menu;</code></pre></li><li><p>QAction</p><pre><code>  QAction *OpenAction =   menu-&gt; addAction(&quot;&amp;Open&quot;,  // 名字                   this,                    &amp; MyMainWindow::sl_open,   //  处理函数                    QKeySequence::Open     //  快捷键                    );</code></pre></li></ul><h2 id="QToolBar"><a href="#QToolBar" class="headerlink" title="QToolBar"></a>QToolBar</h2><pre><code>QToolBar *toolBar = this-&gt;addToolBar(&quot;MyToolBar&quot;);  toolBar-&gt;addAction(OpenAction);toolBar-&gt;addAction(SaveAction);toolBar-&gt;addAction(ExitAction);</code></pre><h2 id="QStatusBar-layout？"><a href="#QStatusBar-layout？" class="headerlink" title="QStatusBar   //  layout？"></a>QStatusBar   //  layout？</h2><pre><code>QStatusBar * statusBar = this-&gt;statusBar();</code></pre><h2 id="QSystemTrayIcon"><a href="#QSystemTrayIcon" class="headerlink" title="QSystemTrayIcon"></a>QSystemTrayIcon</h2><ul><li><p>系统托盘图标</p><pre><code>  _icon = new QSystemTrayIcon();  _icon-&gt;setIcon(QIcon(&quot;../favicon.ico&quot;));      _icon-&gt;setToolTip(&quot;This is tray icon test&quot;);  _icon-&gt;show();  _icon-&gt;setContextMenu(_menu);   //  点击菜单</code></pre></li><li><p>点击显示隐藏</p><pre><code>  connect(_icon,          &amp;QSystemTrayIcon::activated,          this,          &amp; MyMainWindow::sl_iconevent);  void MyMainWindow::sl_iconevent(QSystemTrayIcon::ActivationReason reason)  &#123;      if(reason == QSystemTrayIcon::Trigger)      &#123;          if(this-&gt;isHidden())              this-&gt;show();          else &#123;              this-&gt;hide();          &#125;      &#125;  &#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File I/O</title>
      <link href="/2020/12/01/qt-9-file/"/>
      <url>/2020/12/01/qt-9-file/</url>
      
        <content type="html"><![CDATA[<h1 id="文件-I-O-处理"><a href="#文件-I-O-处理" class="headerlink" title="文件 I/O 处理"></a>文件 I/O 处理</h1><h2 id="QFile"><a href="#QFile" class="headerlink" title="QFile"></a>QFile</h2><pre><code>QFile file("../Mytest.txt");</code></pre><ul><li><p>打开</p><pre><code>  file.open(QIODevice::ReadWrite);</code></pre></li><li><p>读写</p><pre><code>  file.write("abc", 4);</code></pre></li><li><p>关闭</p><pre><code>  file.close();</code></pre></li></ul><h2 id="QByteArray-和-QString-区别"><a href="#QByteArray-和-QString-区别" class="headerlink" title="QByteArray 和 QString 区别"></a>QByteArray 和 QString 区别</h2><ul><li>QByteArray 字节数 与外部 IO 交互</li><li>QString 字符数</li></ul><h2 id="QBuffer-缓存区"><a href="#QBuffer-缓存区" class="headerlink" title="QBuffer  缓存区"></a>QBuffer  缓存区</h2><pre><code>QBuffer buffer;buffer.open(QIODevice::ReadWrite);buffer.write("abc");buffer.write("aabbcc");buffer.close();</code></pre><h2 id="QBuffer-将-图片-保存在缓存区再读取"><a href="#QBuffer-将-图片-保存在缓存区再读取" class="headerlink" title="QBuffer 将 图片 保存在缓存区再读取"></a>QBuffer 将 图片 保存在缓存区再读取</h2><pre><code>//  1. 创建 QBufferQBuffer buffer;//  2. 打开缓存区 I/O 操作方式buffer.open(QIODevice::ReadWrite);//  3. 创建QPixmapQPixmap pixmap("../xxx.png");//  4. 将 pixmap 保存在 bufferpixmap.save(&amp;buffer,"PNG"); //  IO 格式//  5. 关闭bufferbuffer.close();//  将缓存区的图片加载到pixmapQPixmap pixmap_w;pixmap_w.loadFromData(buffer.buffer(), "PNG");</code></pre><h2 id="QTextStream"><a href="#QTextStream" class="headerlink" title="QTextStream"></a>QTextStream</h2><ul><li><p>可以将多种类型的数据组合, 相当于 echo</p><pre><code>  QFile file("../xxx.txt");  file.open(QIODevice::ReadWrite);  QTextStream textstream(&amp;file);  textstream &lt;&lt; 1 &lt;&lt; 1.2 &lt;&lt; "zzz";  file.close();</code></pre></li></ul><h2 id="QDataStream"><a href="#QDataStream" class="headerlink" title="QDataStream"></a>QDataStream</h2><ul><li><p>可以将多种类型的数据组合, 可以规定格式后存入取出</p><pre><code>  QFile file("../file.txt");  file.open(QIODevice::ReadWrite);  QDataStream datastream(&amp;file);  int a = 0;  double b =1.2;  QString c = "zzz";  datastream &lt;&lt; a &lt;&lt; b &lt;&lt; c;</code></pre></li></ul><h2 id="virtual-memory"><a href="#virtual-memory" class="headerlink" title="virtual memory"></a>virtual memory</h2><pre><code>QFile file("../xxx.data");file.open(QIODevice::ReadWrite);file.seek(65535);   // 设置索引的位置 |  字符设备不处理 / 块设备处理 file.write("1");file.close();file.open(QIODevice::ReadWrite);uchar* ptr = file.map(0, 64*1024);*ptr = 'a';ptr[3] = 'b';file.unmap(ptr);file.close();</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPainter Pro</title>
      <link href="/2020/11/30/qt-7-dialog/"/>
      <url>/2020/11/30/qt-7-dialog/</url>
      
        <content type="html"><![CDATA[<h1 id="QDialog"><a href="#QDialog" class="headerlink" title="QDialog"></a>QDialog</h1><ul><li>Dialog 和 Widget 的区别 Dialog 无放大缩小按钮</li></ul><h2 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h2><hr><pre><code>dlg-&gt;exec();</code></pre><hr><ul><li><p>模态对话框 在模态对话框中 exec 有自己的消息循环并把 app 的消息循环接管了</p></li><li><p>dialog 是通过 <strong>exec</strong> 来显示 可通过 <strong>accept</strong> 和 <strong>reject</strong> 来关闭窗口</p></li></ul><hr><pre><code>dlg-&gt;show();</code></pre><hr><ul><li>普通对话框用 <strong>close( )</strong> 关闭</li><li></li></ul><h2 id="QFileDialog"><a href="#QFileDialog" class="headerlink" title="QFileDialog"></a>QFileDialog</h2><ul><li>用于打开文件  保存文件等</li></ul><hr><pre><code>QFileDialog * f_dlg;f_dlg = new QFileDialog(NULL,"filedlg",_strDir,"Png File (*.png)");</code></pre><hr><ul><li>getSaveFileName</li></ul><hr><pre><code>//  返回的文件目录储存在 strFilename 用于下一次打开时在当前目录QString strFilename = QFileDialog::getSaveFileName(NULL,                            "filedlg",  //  Title                            _strDir,    //  Dir                            "Png File (*.png)"  //  file type                            );//  创建一个 QFileInfo 存储上一步的文件路径QFileInfo fileinfo(strFilename);_strDir = fileinfo.filePath();</code></pre><hr><h2 id="QMessageBox"><a href="#QMessageBox" class="headerlink" title="QMessageBox"></a>QMessageBox</h2><hr><pre><code>QMessageBox::warning(this, "Error", "Error msgs ....");QMessageBox::information(this, "Error", "information msgs ....");// x 符号那种QMessageBox::critical(this,"critical", "critical msgs .....");//  选择int ret = QMessageBox::question(this, "???", "ready do ?",                                QMessageBox::Yes| QMessageBox::No | QMessageBox::Ok | QMessageBox::NoAll);if(ret == QMessageBox::Yes){    qDebug() &lt;&lt; "yes";}if(ret == QMessageBox::No){    qDebug() &lt;&lt; "no";}</code></pre><hr><h2 id="其他的-Dialog"><a href="#其他的-Dialog" class="headerlink" title="其他的 Dialog"></a>其他的 Dialog</h2><ul><li>QColorDialog</li><li>QFontDialog</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPainter Pro</title>
      <link href="/2020/11/28/qt-6-painterpro/"/>
      <url>/2020/11/28/qt-6-painterpro/</url>
      
        <content type="html"><![CDATA[<h1 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h1><ul><li>三要素<ul><li>画在什么设备上？    pixmap  </li><li>用什么画在什么上？  painter =&gt; pixmap</li><li>渲染在什么部件上（render）？  QGraphicsView QGraphicsScene</li></ul></li></ul><h2 id="QGraphicsView"><a href="#QGraphicsView" class="headerlink" title="QGraphicsView"></a>QGraphicsView</h2><ul><li>显示</li></ul><hr><pre><code>_view = new QGraphicsView(this);</code></pre><hr><h2 id="QGraphicsScene"><a href="#QGraphicsScene" class="headerlink" title="QGraphicsScene"></a>QGraphicsScene</h2><ul><li>现场  添加到显示里</li></ul><hr><pre><code>_view-&gt;setScene(_scene = new QGraphicsScene);</code></pre><hr><ul><li>在现场中添加 <strong>item</strong> </li><li>修改 <strong>item</strong> 的样式  </li></ul><hr><pre><code>_scene-&gt;addItem(lineitem = new QGraphicsLineItem(0,0,100,100));_scene-&gt;addItem(textitem = new QGraphicsTextItem("ohayo"));_scene-&gt;addItem(pixmapItem = new QGraphicsPixmapItem(QPixmap("../xxxx.png")));textitem-&gt;setPos(QPointF(200, 300));textitem-&gt;setFont(QFont("aaa",50,20,1));pixmapItem-&gt;setPos(100,100);</code></pre><hr><h1 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h1><ul><li>先渲染图片<ul><li>三要素： 设备 画笔 渲染 ==&gt; 保存</li></ul></li></ul><hr><p>//        _view-&gt;render()   //重新操作一遍<br>//        _scene-&gt;render()</p><pre><code>    QPixmap pixmap(size()); //  先要有一个画的设备    QPainter painter(&amp;pixmap);  //  画的工具    painter.fillRect(QRect(0,0,size().width(),size().height()),Qt::white);  //  画板背景    _scene-&gt;render(&amp;painter);   //  渲染  用什么渲染（画笔） 在什么上渲染（pixmap）    pixmap.save("../abb.png");</code></pre><hr><h1 id="QGraphicsItemAnimation-动画"><a href="#QGraphicsItemAnimation-动画" class="headerlink" title="QGraphicsItemAnimation 动画"></a>QGraphicsItemAnimation 动画</h1><ul><li>加入 item ==&gt; 设置QTimeline  ==&gt; 循环次数 ==&gt; </li></ul><hr><pre><code>QGraphicsItemAnimation * animation = new QGraphicsItemAnimation;animation-&gt;setItem(pixmapItem);QTimeLine* timeline = new QTimeLine(3000);  // mstimeline-&gt;setLoopCount(2);animation-&gt;setTimeLine( timeline );animation-&gt;setTranslationAt(1,200,200);timeline-&gt;start();</code></pre><hr><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><hr><pre><code>timer = new QTimer();timer-&gt;setInterval(1000);   // 间隔1s// 超时做的事 connectconnect(timer,        &amp;QTimer::timeout,        this,        &amp;MyWidget::sl_timeout);timer-&gt;start();    //  只触发一次timer-&gt;singleShot(1000,this,&amp;MyWidget::sl_timeout);</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号槽</title>
      <link href="/2020/11/25/qt-5-xin-hao-cao/"/>
      <url>/2020/11/25/qt-5-xin-hao-cao/</url>
      
        <content type="html"><![CDATA[<h1 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h1><ul><li>信号的定义必须在 <strong>signals</strong> 保留字下，并且不需要实现</li><li>槽的定义在 <strong>slots</strong> 保留字下，需要实现 </li><li>信号和槽通过 QObject::connect 函数连接</li><li>当信号被触发 槽函数被调用</li></ul><hr><ul><li>信号和槽是QT的扩展 所以实现信号和槽的类必须是 <strong>QObject</strong> 的子类</li><li>实现信号和槽的类 必须以宏 <strong>Q_OBJECT</strong> 开始</li><li>连接信号和槽，要用到 <strong>SINGAL</strong> 和 <strong>SLOT</strong> 宏 转换函数为字符串</li><li>一个信号可以连接<strong>多个</strong>槽 槽函数调用顺序是不确定的</li><li>多个信号可以同时连接一个槽</li><li>信号可以连接信号，形成信号传导</li><li>信号和槽的<strong>参数</strong>应该一样多 而且<strong>类型</strong>必须相同</li><li>信号和槽都可以重载</li><li>信号和槽都可以有默认参数</li><li>槽函数可以像普通函数一样被调用</li><li>在槽函数中调用 <strong>sender</strong> 可以获得信号调用者</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一个类-QObject"><a href="#一个类-QObject" class="headerlink" title="一个类 QObject"></a>一个类 QObject</h3><h3 id="三个宏-Q-OBJECT-SIGNAL-SLOT"><a href="#三个宏-Q-OBJECT-SIGNAL-SLOT" class="headerlink" title="三个宏 Q_OBJECT SIGNAL SLOT"></a>三个宏 Q_OBJECT SIGNAL SLOT</h3><h3 id="三个保留字-signals-slots-emit"><a href="#三个保留字-signals-slots-emit" class="headerlink" title="三个保留字 signals slots emit"></a>三个保留字 signals slots emit</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT绘画</title>
      <link href="/2020/11/24/qt-4-painter/"/>
      <url>/2020/11/24/qt-4-painter/</url>
      
        <content type="html"><![CDATA[<h1 id="QT绘画-QPainter"><a href="#QT绘画-QPainter" class="headerlink" title="QT绘画 QPainter"></a>QT绘画 QPainter</h1><ul><li><p>重载 paintEvent</p><ol><li><p>准备画笔</p><pre><code> QPainter p(this);     p.setPen(QPen(Qt::red, 2, Qt::DashLine));     p.setBrush(Qt::yellow); //  背景颜色     p.setFont(QFont("aaa", 40, 700, true)); //italic</code></pre></li><li><p>绘制形状</p><pre><code> p.drawLine(QPoint(0,0), QPoint(100,100)); p.drawRect(QRect(40,60,100,50)); p.drawText(QPoint(300, 50), "Hellow"); p.drawPixmap(QPoint(40,40), QPixmap("../aaa.png"));</code></pre></li><li><p>图形变换</p><pre><code> {     QTransform transfrom;       //  可将复杂的功能组合     transfrom.rotate(30);     transfrom.scale(.5,.5);     //  缩放     p.setTransform(transfrom);  //  旋转 } p.translate(100,100);   //  变换原点坐标单独</code></pre></li><li><p>消除锯齿</p><pre><code> p.setRenderHint(QPainter::Antialiasing);    //  消除锯齿    </code></pre></li><li><p>*可以先画好图片放入pixmap中，再在窗口绘制</p><pre><code> QPixmap pixmap(size()); QPainter p(&amp;pixmap); QTransform transform; transform.translate(50,50); transform.rotate(30); p.setTransform(transform); p.drawxxx    ... ...  P.end(); p.begin(this); p.drawPixmap(0,0,pixmap);</code></pre></li></ol></li></ul><h2 id="示例1（画板实现）"><a href="#示例1（画板实现）" class="headerlink" title="示例1（画板实现）"></a>示例1（画板实现）</h2><hr><pre><code>// MyWidget.h #include&lt;QVector&gt;#include &lt;QDebug&gt;    class MyWidget : public QWidget{    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);    MyButton * button;    void paintEvent(QPaintEvent *);    void mousePressEvent(QMouseEvent *);    void mouseReleaseEvent(QMouseEvent *);    void mouseMoveEvent(QMouseEvent *);    QVector&lt;QPoint&gt; _pos;    QVector&lt; QVector&lt;QPoint&gt; &gt; _lines;signals:};</code></pre><hr><hr><pre><code>//MyWidget.cppvoid MyWidget::paintEvent(QPaintEvent *event){    QPainter p(this);    for(int i = 0; i &lt; _lines.size();++i)    {        const QVector&lt;QPoint&gt; &amp; line = _lines.at(i);        {            for(int j = 0; j &lt; line.size()-1; ++j)            {                p.drawLine(line.at(j),line.at(j+1));            }        }    }}void MyWidget::mouseMoveEvent(QMouseEvent *event){    if(_lines.size() == 0)    {        QVector&lt;QPoint&gt; line;        _lines.append(line);    }    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());    update();}void MyWidget::mouseReleaseEvent(QMouseEvent *event){    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());}void MyWidget::mousePressEvent(QMouseEvent *event){    QVector&lt;QPoint&gt; line;   //  一条线    _lines.append(line);     // 一条线放入很多条线 的向量里    QVector&lt;QPoint&gt;&amp; lastline = _lines.last();    lastline.append(event-&gt;pos());//    _pos.append(event-&gt;pos());}</code></pre><hr><h2 id="示例2-按钮变色"><a href="#示例2-按钮变色" class="headerlink" title="示例2 按钮变色"></a>示例2 按钮变色</h2><hr><pre><code>//  MyButton.h#ifndef MYBUTTON_H#define MYBUTTON_H#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;class MyButton : public QWidget{    Q_OBJECTpublic:    explicit MyButton(QWidget *parent = nullptr);    MyButton(const QString &amp;text, QWidget* parent = 0);    QRect _rect;    //  按钮大小    QString _text;  //  按钮显示文字    bool _pressed;  //  按压判断    void paintEvent(QPaintEvent *event);    void mousePressEvent(QMouseEvent *event);    void mouseReleaseEvent(QMouseEvent *event);signals:    void clicked();};#endif // MYBUTTON_H</code></pre><hr><hr><pre><code>//  MuButton.cpp#include "MyButton.h"#include &lt;QPainter&gt;MyButton::MyButton(QWidget *parent) :    QWidget(parent), _rect(0,0,100,30){    _pressed = false;   //  初始时 按压设置为否    this-&gt;setGeometry(_rect);}MyButton::MyButton(const QString &amp;text, QWidget *parent):                        QWidget(parent), _text(text), _rect(0,0,100,30){    _pressed = false;    this-&gt;setGeometry(_rect);}void MyButton::paintEvent(QPaintEvent *event){    QPainter p(this);    if( _pressed == true )    {        p.setBrush(Qt::yellow); //  设置背景为黄色    }    else        p.setBrush(Qt::darkGray);   //  设置背景为灰色    p.drawRect(_rect);  //  画按钮框    p.drawText(_rect, _text, QTextOption(Qt::AlignCenter)); //  画文字}void MyButton::mousePressEvent(QMouseEvent *event){    //  按下时 按钮状态为 true 更新颜色    _pressed = true;    update();}void MyButton::mouseReleaseEvent(QMouseEvent *event){    //  释放时 按钮状态为 false 更新颜色    _pressed = false;    update();    //  在设定框框的容器范围内才发送信号    if(_rect.contains(event-&gt;pos()))    {    emit clicked();    }//    emit clicked();}</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT控件</title>
      <link href="/2020/11/24/qt-3-shi-jian/"/>
      <url>/2020/11/24/qt-3-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><ul><li><p>QApplication 先得到 ==&gt; 具体应该处理的窗口：event() ==&gt; event() 根据消息的类型来调用具体的虚函数 </p></li><li><p>重载具体的虚函数来实现对消息的相应</p></li><li><p>重载 event 函数来处理或截取消息</p></li></ul><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><ol><li>在处理的类里重载事件</li></ol><hr><pre><code>class MyWidget : public QWidget{    Q_OBJECTpublic:    explicit MyWidget(QWidget *parent = nullptr);// *************** event **********************//    bool event(QEvent *);    void mousePressEvent(QMouseEvent *event);    void mouseReleaseEvent(QMouseEvent *event);    void mouseMoveEvent(QMouseEvent *event);    void keyPressEvent(QKeyEvent *event);    void closeEvent(QCloseEvent *event);    void hideEvent(QHideEvent *event);    void paintEvent(QPaintEvent *event);    void resizeEvent(QResizeEvent *event);// *********************************************    QPushButton *button;    QPushButton *button1;    QVBoxLayout *vlay;    QTextEdit * edit;    void sl_buttonChecked();signals:};</code></pre><hr><ol start="2"><li><p>截断消息</p><p> 重载event函数来处理或者截取消息</p></li></ol><hr><pre><code>bool MyWidget::event(QEvent *ev){    if(ev-&gt;type() == QEvent::MouseButtonPress)    {        qDebug()&lt;&lt;"111";        return QWidget::event(ev);    }}</code></pre><hr><ol start="3"><li><p>重写 事件</p><p> 重载具体的虚函数来实现对消息的相应</p></li></ol><hr><pre><code>void MyWidget::keyPressEvent(QKeyEvent *event){    event-&gt;modifiers() ;    int key = event-&gt;key();    qDebug()&lt;&lt;key;    char keys = key;    qDebug()&lt;&lt;keys;}void MyWidget::mousePressEvent(QMouseEvent *event){    QPoint pt = event-&gt;pos();    qDebug()&lt;&lt;pt;    if(event-&gt;button() == Qt::LeftButton)    {        qDebug()&lt;&lt;"left";    }    if(event-&gt;modifiers()== Qt::ShiftModifier)  //  修饰符shift    {        qDebug()&lt;&lt;"shift press";    }    if(event-&gt;modifiers() == Qt::ControlModifier)    {        qDebug()&lt;&lt;"control";        return ;    }}   </code></pre><hr><ol start="4"><li><p>注意事项</p><ul><li><p>鼠标事件在窗口上处理不包含按钮等部件  鼠标按下才会有反应</p><p>  解决方法: </p><pre><code>  this-&gt;setMouseTracking(true);</code></pre></li></ul></li></ol><pre><code>* 键盘事件在主窗口上处理, 不会处理按键等    解决方法: 设置 焦点 or 将按键设置默认        button-&gt;setFocus(); //  设置焦点        button-&gt;setDefault(true);   //  设为默认</code></pre><h2 id="事件过滤"><a href="#事件过滤" class="headerlink" title="事件过滤"></a>事件过滤</h2><ol><li><p>给 <strong>Widget</strong> 安装一个消息过滤器， 经过 <strong>Widget</strong> 的消息都要先经过 <strong>eventfilter</strong> </p><pre><code> button-&gt;installEventFilter(this);</code></pre></li><li><p>重写 eventFilter 函数</p><pre><code> bool eventFilter(QObject *, QEvent *); bool MyWidget::eventFilter(QObject *o, QEvent *e) {     if(((QPushButton *)_button == o ) &amp;&amp;             (e-&gt;type() == QEvent::MouseButtonRelease ||             e-&gt;type() == QEvent::MouseButtonDblClick||             e-&gt;type() == QEvent::MouseButtonPress))     {         return true;     }     return QWidget::eventFilter(o,e); }</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT控件</title>
      <link href="/2020/11/23/qt-2-kong-jian/"/>
      <url>/2020/11/23/qt-2-kong-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><h2 id="QLabel-addWidget"><a href="#QLabel-addWidget" class="headerlink" title="QLabel   (addWidget)"></a>QLabel   (addWidget)</h2><ul><li>是一个部件，添加到布局里</li><li>标签的文字支持 html 语言</li></ul><h2 id="QComboBox-（addWidget）"><a href="#QComboBox-（addWidget）" class="headerlink" title="QComboBox    （addWidget）"></a>QComboBox    （addWidget）</h2><ul><li>下拉框</li></ul><hr><pre><code>QComboBox *combo;lay-&gt;addWidget(combo = new QComboBox());</code></pre><hr><ul><li>添加选项</li></ul><hr><pre><code>combo-&gt;addItem("select 1");combo-&gt;addItem("select 2");</code></pre><hr><ul><li>可编辑选项</li></ul><hr><pre><code>combo-&gt;setEditable(true);  // 可编辑的下拉框</code></pre><hr><ul><li>根据输入选择下拉选项</li></ul><hr><pre><code>combo-&gt;setCompleter(new QCompleter(combo-&gt;model()));</code></pre><hr><h2 id="QTextEdit-addWidget"><a href="#QTextEdit-addWidget" class="headerlink" title="QTextEdit     (addWidget)"></a>QTextEdit     (addWidget)</h2><ul><li>文本编辑框 可以给定 Html 语言格式，如&lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;imag src=../xxx.png&gt;&lt;\imag&gt;…</li></ul><hr><pre><code>lay-&gt;addWidget(edit = new QTextEdit);    edit-&gt;setText("&lt;table border=1&gt;&lt;tr&gt;&lt;th&gt;head1&lt;/th&gt;&lt;/tr&gt;"                "&lt;tr&gt;&lt;td&gt;value1&lt;/td&gt;value2&lt;td&gt;zzz&lt;/td&gt;&lt;/1tr&gt;"                "&lt;tr&gt;&lt;td&gt;value3&lt;/td&gt;value4&lt;td&gt;zzz&lt;/td&gt;&lt;/tr&gt;"                "&lt;/table&gt;""&lt;br&gt;""&lt;imag src=../aaa.png&gt;&lt;/imag&gt;"                );        //Html 表格插数据</code></pre><hr><ul><li>检测文本路径转为图片显示</li></ul><hr><pre><code>edit-&gt;toPlainText();</code></pre><hr><ul><li>侧边移动滑条</li></ul><hr><pre><code>edit-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);edit-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);</code></pre><hr><h2 id="QGroupBox-addWidget"><a href="#QGroupBox-addWidget" class="headerlink" title="QGroupBox    (addWidget)"></a>QGroupBox    (addWidget)</h2><ul><li>左上角名字将部件圈起来的框框</li></ul><hr><pre><code>lay-&gt;addWidget(groupbox = new QGroupBox("Some Items"));</code></pre><hr><p>*再在框框内添加layout, 再在layout内添加部件</p><hr><pre><code>groupbox-&gt;setLayout(hboxlay = new QHBoxLayout);hboxlay-&gt;addWidget(new QLabel("aaaa"));hboxlay-&gt;addWidget(new QLabel("aaaa"));</code></pre><hr><h2 id="QSlider-（滑杆）"><a href="#QSlider-（滑杆）" class="headerlink" title="QSlider  （滑杆）"></a>QSlider  （滑杆）</h2><ul><li>布局 默认竖直放置, 下面为水平放置</li></ul><hr><pre><code>lay-&gt;addWidget(slider = new QSlider(Qt::Horizontal));</code></pre><hr><ul><li>设置上下限</li></ul><hr><pre><code>slider-&gt;setMaximum(100);slider-&gt;setMinimum(0);</code></pre><hr><h2 id="QSpinBox-（数字调节）"><a href="#QSpinBox-（数字调节）" class="headerlink" title="QSpinBox     （数字调节）"></a>QSpinBox     （数字调节）</h2><hr><pre><code>lay-&gt;addWidget(spinBox = new QSpinBox); </code></pre><hr><h3 id="将-QSlider-与-QSpinBox-结合"><a href="#将-QSlider-与-QSpinBox-结合" class="headerlink" title="将 QSlider 与 QSpinBox 结合"></a>将 QSlider 与 QSpinBox 结合</h3><hr><pre><code>connect(slider,        &amp;QSlider::valueChanged,        spinBox,        &amp;QSpinBox::setValue);connect(spinBox,        SIGNAL(valueChanged(int)),        slider,        SLOT(setValue(int)));</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux C线程</title>
      <link href="/2020/11/18/c-thread/"/>
      <url>/2020/11/18/c-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><hr><pre><code>#include &lt;pthread.h&gt;</code></pre><hr><h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><hr><pre><code>extern int pthreacreated_create (pthread_t *__restrict __newthread,           const pthread_attr_t *__restrict __attr,           void *(*__start_routine) (void *),           void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>线程ID的指针</li></ul><hr><pre><code>pthread_t *__restrict __newthread,</code></pre><hr><pre><code>//  创建方式pthread_t work_thread;pthread_t wait_thread;</code></pre><ul><li>线程属性设置</li></ul><hr><pre><code>const pthread_attr_t *__restrict __attr,</code></pre><hr><pre><code>//  创建属性pthread_attr_t attr;       //线程属性设置pthread_attr_init(&amp;attr);//将属性设置为joinable, 使主线程等待该线程执行完后，再结束主线程pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_JOINABLE);   </code></pre><ul><li>执行的线程函数  &amp;  参数</li></ul><hr><pre><code>//  函数参数void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><pre><code>//  创建传递线程参数的结构体struct thread_para{    int sockfd;    char *info;};thread_para thread_p;</code></pre><hr><pre><code>//  函数指针void *(*__start_routine) (void *),</code></pre><hr><hr><pre><code>//  创建线程函数void *work_recv_thread(void *param){    //  将传入的结构体强转类型    thread_para *t_para = (thread_para* )param;    ... ...}</code></pre><hr><ul><li>创建线程</li></ul><hr><pre><code>extern int pthread_create (pthread_t *__restrict __newthread,           const pthread_attr_t *__restrict __attr,           void *(*__start_routine) (void *),           void *__restrict __arg) __THROWNL __nonnull ((1, 3));</code></pre><hr><hr><pre><code>创建一个线程pthread_create(    &amp;work_thread,    NULL,    work_recv_thread,    (void *)&amp;thread_p);</code></pre><hr><ul><li>阻塞式(等待子线程运行完再结束主线程)</li></ul><hr><pre><code>extern int pthread_join (pthread_t __th, void **__thread_return);pthread_t __th  //  线程IDvoid **__thread_return  //  返回的线程状态信息，类型为void*//ex:void *status;pthread_join(    wait_thread,    &amp;status);</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT基础</title>
      <link href="/2020/11/15/qt-1-ji-chu/"/>
      <url>/2020/11/15/qt-1-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="QT基础"><a href="#QT基础" class="headerlink" title="QT基础"></a>QT基础</h1><h2 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h2><ul><li>空的父系窗口，可以包含QPushbutton、QLineEdit、Layout等部件</li></ul><hr><pre><code>QWidget w;w.setWindowTitle("zzz");//  显示窗口w.show();</code></pre><hr><h2 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h2><ul><li>按钮也是一个窗口 继承QWidget</li></ul><hr><pre><code>QPushButton button;button.setText("quit");</code></pre><hr><ol><li>窗口之间存在父子关系,没有父子对象的窗口为主窗口</li></ol><hr><pre><code>button.setParent(&amp;w);</code></pre><hr><ol start="2"><li>setGeometry(x, y, l, w) 设置几何位置</li></ol><hr><pre><code>button.setGeometry(20,20,100,30);</code></pre><hr><h2 id="QLineEdit"><a href="#QLineEdit" class="headerlink" title="QLineEdit"></a>QLineEdit</h2><ul><li>文本输入框</li></ul><hr><pre><code>QLineEdit edit;edit.setParent(&amp;w);</code></pre><hr><ol><li>显示方式(输入密码那种样子)</li></ol><hr><pre><code>edit.setEchoMode(QLineEdit::Password);edit.text();</code></pre><hr><ol start="2"><li><p>输入匹配</p><p> (1) 创建一个预期的QStringList</p><p> (2) 创建一个QCompleter completer(QStringList()&lt;&lt;””);</p><p> (3) 匹配模式<br> completer.setFilterMode(Qt::MatchContains)</p><p> (4) 设置模式到QLineEdit</p></li></ol><hr><pre><code>QCompleter completer(QStringList()&lt;&lt;"123" &lt;&lt;"abc");completer.setFilterMode(Qt::MatchContains);edit.setCompleter(&amp;completer);</code></pre><hr><ol start="3"><li>默认显示</li></ol><hr><pre><code>edit.setPlaceholderText("gogogo");edit.setParent(&amp;w);</code></pre><hr><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><ul><li><p>用<strong>QVBoxLayout</strong>、<strong>QHBoxLayout</strong>、<strong>QGridLayout</strong> 创建一个Layout</p></li><li><p>将按钮啥的放到 部件 里 layout.addWidget()</p></li><li><p>将Layout放到 QWidget 里 addWidget(&amp; layout)</p><ol><li>添加空位addSpacing</li><li>addStretch 弹簧一样将layout中的 部件 压到一块 参数为比例</li></ol></li></ul><hr><pre><code>QHBoxLayout h_layout;//  addWidget 第二个参数是部件的长度比例h_layout.addWidget(&amp;button,1);h_layout.addWidget(&amp;edit,2);h_layout.addStretch(2);w.setLayout(&amp;h_layout);</code></pre><hr><ul><li>QGridLayout 矩阵式多个部件</li></ul><hr><pre><code>QGridLayout g_layout;//  QGridLayout 矩阵式多个部件g_layout.addWidget(&amp;button,0,0);g_layout.addWidget(&amp;edit,0,1);g_layout.addWidget(new QPushButton("1, 0"),1,0);g_layout.addWidget(new QPushButton("1, 1"),1,1);g_layout.setColumnStretch(2,1);g_layout.setRowStretch(2,1);w.setLayout(&amp;g_layout);</code></pre><hr><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><hr><pre><code>//  登录界面/*  1. 居中 *  2. 用户名 label   edit *  3. 密码   label   edit *  4. 确认   button *      */QWidget *w = new QWidget;QLabel *m_l_username = new QLabel;QLabel *m_l_passwd = new QLabel;QLineEdit *m_e_username = new QLineEdit;QLineEdit *m_e_passwd = new QLineEdit;QPushButton *m_login_bt = new QPushButton;QGridLayout *m_login_glayout = new QGridLayout;QHBoxLayout *m_login_bt_l = new QHBoxLayout;m_l_username-&gt;setText("用户名:");m_login_glayout-&gt;addWidget(m_l_username,1,1);//  m_login_glayout-&gt;setSpacing(10);m_e_username-&gt;setMaxLength(8);m_login_glayout-&gt;addWidget(m_e_username,1,2);m_l_passwd-&gt;setText("密码:");m_login_glayout-&gt;addWidget(m_l_passwd,2,1);m_login_glayout-&gt;setSpacing(10);m_e_passwd-&gt;setEchoMode(QLineEdit::Password);m_login_glayout-&gt;addWidget(m_e_passwd,2,2);m_login_glayout-&gt;setRowStretch(0,1);m_login_glayout-&gt;setColumnStretch(0,1);m_login_glayout-&gt;setRowStretch(4,1);m_login_glayout-&gt;setColumnStretch(4,1);m_login_bt-&gt;setText("登录");m_login_bt_l-&gt;addStretch(1);m_login_bt_l-&gt;addWidget(m_login_bt);m_login_glayout-&gt;addLayout(m_login_bt_l,3,2);//    m_login_glayout-&gt;addWidget(m_login_bt,3,2);w-&gt;setLayout(m_login_glayout);//    w-&gt;setLayout()w-&gt;show();</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT窗口部件</title>
      <link href="/2020/11/07/qt-1/"/>
      <url>/2020/11/07/qt-1/</url>
      
        <content type="html"><![CDATA[<h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><h3 id="一-各种部件"><a href="#一-各种部件" class="headerlink" title="一.  各种部件"></a>一.  各种部件</h3><ul><li><strong>QWidget</strong> 现理解的作用就是包起其他的部件，如QVboxLayout</li></ul><hr><pre><code>// 创建一个QWidegetQWidget w;  //  创建实例对象QWidget *w1 = new QWidget;  //  创建指针(推荐)</code></pre><hr><ul><li><strong>QVBoxLayout(QHboxLayout)</strong> 存放各种按钮框框啥的吧</li></ul><hr><pre><code>//  创建一个QVBoxLayoutQVBoxLayout box;  //  创建实例对象QVBoxLayout *box = new QVBoxLayout;  //  创建指针</code></pre><hr><ul><li><strong>QPushButton</strong> 按钮</li></ul><hr><pre><code>QPushButton quit("quit");//  1.将按钮放入 BoxLayoutbox-&gt;addWidget(&amp;hello);QObject::connect(        &amp;quit,                  // 按下buttom发出信号的对象        &amp;QPushButton::clicked,  // 点击信号          &amp;a,                     // 接受信号的对象        &amp;QApplication::quit     // 槽 实现功能 退出        );//  2.BoxLayout 放入 QWidgetw-&gt;setLayout(&amp;box);//  3.显示w-&gt;show();</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与指针</title>
      <link href="/2020/10/24/array-point/"/>
      <url>/2020/10/24/array-point/</url>
      
        <content type="html"><![CDATA[<h2 id="数据与指针"><a href="#数据与指针" class="headerlink" title="数据与指针"></a>数据与指针</h2><h3 id="一-概念"><a href="#一-概念" class="headerlink" title="一.  概念"></a>一.  概念</h3><ul><li>数组：储存多个相同类型元素</li><li>指针：自身储存指向对象的地址</li></ul><h3 id="二-赋值"><a href="#二-赋值" class="headerlink" title="二. 赋值"></a>二. 赋值</h3><blockquote><p>数组</p><ul><li>1</li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/10/24/hello-world/"/>
      <url>/2020/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/08/02/test/"/>
      <url>/2020/08/02/test/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>print("hello world")</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
